rownames(summary_stats$summary)), ]
summary_stats$summary[grep("gamma",
rownames(summary_stats$summary)), ]
#################
##  Save Model ##
#################
saveRDS(fit_full_bayes, file = "./03_Data/ZZ_Temp/fit_full_bayes.rds")
# Extract model parameters and posterior predictions
##############################################################
fit_het_blue <- readRDS(file = "./03_Data/ZZ_Temp/fit_full_bayes.rds")
load('./03_Data/ZZ_Temp/panel_het_blue.RData')
G <- panel_list$G
############################
## Extract the parameters ##
############################
phi_a <- rstan::extract(fit_full_bayes, par='phi_a')[[1]]
phi_0 <- rstan::extract(fit_full_bayes, par='phi_0')[[1]]
mu <- rstan::extract(fit_full_bayes, par='Mu')[[1]]
##########################################
## Posterior predictive counterfactuals ##
##########################################
PosteriorPredictions = NA*mu
nIter = dim(mu)[1]
nUnits = dim(mu)[2]
nTimes = dim(mu)[3]
for (b in 1:nIter) {
for (i in 1:nUnits) {
for (t in 1:nTimes) {
if (t < G[i]) {
PosteriorPredictions[b,i,t] = rnbinom( 1, mu=mu[b,i,t], size=phi_0[b])
} else {
PosteriorPredictions[b,i,t] = rnbinom( 1, mu=mu[b,i,t], size=phi_a[b])
}
}
}
}
##########
## Save ##
##########
save(PosteriorPredictions,
file = "./03_Data/ZZ_Temp/posterior_predictions_full_bayes.RData")
##  Posterior predictions of the counterfactuals using a copula
##############################################################################
fit_full_bayes <- readRDS(file = "./03_Data/ZZ_Temp/fit_full_bayes.rds")
load('./03_Data/ZZ_Temp/panel_het_blue.RData')
load('./03_Data/ZZ_Temp/HEP_dta_short.RData')
##  Posterior predictions of the counterfactuals using a copula
##############################################################################
fit_full_bayes <- readRDS(file = "./03_Data/ZZ_Temp/fit_full_bayes.rds")
load('./03_Data/ZZ_Temp/panel_het_blue.RData')
load('./03_Data/HEP_dta.RData')
############################
## Extract the parameters ##
############################
phi_a <- rstan::extract(fit_full_bayes, par='phi_a')[[1]]
phi_0 <- rstan::extract(fit_full_bayes, par='phi_0')[[1]]
mu <- rstan::extract(fit_full_bayes, par='Mu')[[1]]
count <- rstan::extract(fit_full_bayes, par='Count')[[1]]
Y <- panel_list$Y
G <- panel_list$G
nIter <- dim(mu)[1]
nUnits <- dim(mu)[2]
nTimes <- dim(mu)[3]
##############################################
##  Set prior for the correlation parameter ##
##############################################
rho_vals <- c(1, .75, .5, 0, -1)
rho_mins <- c(.75, .5, 0, -1)
rho_maxs <- c(1, 1, 1, 1)
# one correlation value
rho_static <- as.data.frame(matrix(NA, nrow = length(rho_vals), ncol = nIter))
for (val in seq_along(rho_vals)) {
rho_static[val, ] <- rep(rho_vals[val], nIter)
}
# correlation values drawn from prior distribution
rho_prior <- as.data.frame(matrix(NA, nrow = length(rho_maxs), ncol = nIter))
for (val in 1:length(rho_mins)) {
rho_prior[val, ] <- runif(nIter,
min = rho_mins[val],
max = rho_maxs[val])
}
rho_df <- rbind(rho_static, rho_prior)
rho_vector <- c(as.character(rho_vals), paste0("unif[", rho_mins, ",", rho_maxs,"]"))
####################################################
##  Get the percentiles from outcome distribution ##
####################################################
## Get P(x <= X)  ##
percentile_max <- NA*mu
for (b in 1:nIter) {
for (i in 1:nUnits) {
for (t in 1:nTimes) {
if (t < G[i]) {
percentile_max[b,i,t] <- pnbinom(Y[i,t],
mu=mu[b,i,t],
size=phi_0[b])
} else {
percentile_max[b,i,t] <- pnbinom(Y[i,t],
mu=mu[b,i,t],
size=phi_a[b])
}
}
}
}
## Get P(x <= X-1)  ##
percentile_min <- NA*mu
for (b in 1:nIter) {
for (i in 1:nUnits) {
for (t in 1:nTimes) {
if (t < G[i]) {
percentile_min[b,i,t] <- pnbinom(Y[i,t]-1,
mu=mu[b,i,t],
size=phi_0[b])
} else {
percentile_min[b,i,t] <- pnbinom(Y[i,t]-1,
mu=mu[b,i,t],
size=phi_a[b])
}
}
}
}
########################
##  Draw a percentile ##
########################
percentile <- NA*mu
for (b in 1:nIter) {
for (i in 1:nUnits) {
for (t in 1:nTimes) {
percentile[b,i,t] <- runif(1,
min = percentile_min[b,i,t],
max = percentile_max[b,i,t])
}
}
}
##############################################################
##  Introduce the correlation and generate counterfactuals  ##
##############################################################
posterior_predictions_copula_list <- list()
# Loop over each correlation value
for (row_idx in 1:nrow(rho_df)) {
print(paste("Generating posteriors for: rho=", rho_vector[row_idx]))
# Get the specific rho value for this iteration
rho <- as.numeric(rho_df[row_idx, ])
################################
##  Introduce the correlation ##
################################
percentile2 <- NA*mu
norm_var1 <- NA*mu
mu2_given_norm_var1 <- NA*mu
sd2_given_norm_var1 <- NA*nIter
norm_var2 <- NA*mu
for (b in 1:nIter) {
for (i in 1:nUnits) {
for (t in 1:nTimes) {
## Get first normally distributed variable
norm_var1[b,i,t] <- qnorm(percentile[b,i,t], mean = 0, sd = 1)
## Compute conditional distribution of norm_var2 | norm_var1
mu2_given_norm_var1[b,i,t] <- rho[b] * norm_var1[b,i,t]
sd2_given_norm_var1[b] <- sqrt(1 - rho[b]^2)
## Sample norm_var2 from conditional distribution
norm_var2[b,i,t] <- rnorm(1,
mean = mu2_given_norm_var1[b,i,t],
sd = sd2_given_norm_var1[b])
## Compute percentile of norm_var2 in the conditional distribution
percentile2[b,i,t] <- pnorm(norm_var2[b,i,t], mean = 0, sd = 1)
}
}
}
##############################
##  Generate counterfactual ##
##############################
Y_0 <- NA*mu
for (b in 1:nIter) {
for (i in 1:nUnits) {
for (t in 1:nTimes) {
Y_0[b,i,t] <- qnbinom(p = percentile2[b,i,t],
mu = count[b,i,t],
size = phi_0[b])
}
}
}
## Save the results for this rho value to the list
posterior_predictions_copula_list[[row_idx]] <- Y_0
names(posterior_predictions_copula_list)[row_idx] <- paste0("rho=",
rho_vector[row_idx])
}
##########
## Save ##
##########
save(posterior_predictions_copula_list,
file = "./03_Data/ZZ_Temp/posterior_predictions_copula_list_full_bayes.RData")
##  Model using pre-intervention outcomes only
################################################################################
rm(list=ls())
library(rstan)
library(rstanarm)
library(bayesplot)
# number of latent factors ##
k <- 1
## load the stan model ##
m_mod <- stan_model("./04_Code/analysis/imputation-estimator/Functions/MC_neg_binom.stan",auto_write=T)
## load the full list of panel data ##
load('./03_Data/ZZ_Temp/panel_het_blue.RData')
###########################
## extract and prep data ##
###########################
## stan doesn't allow missing values so we put a numeric "placeholder" in the missings
Y0_obs <- ifelse(panel_list$D==0,
99999,
panel_list$Y)
## set up the list of data for stan call ##
stan_in <- list(k = k, ## k is user-specified number of factors ##
m = ncol(Y0_obs), # m corresponds to T in our notation (number of time points) ##
n = nrow(Y0_obs), # n is number of counties ##
g = as.vector(panel_list$G), ## G is a vector with first time periods units are treated ##
y = Y0_obs ## y is the observed Y(0) matrix ##
)
###########################
##  model specifications ##
###########################
## Decide which parameters to return ##
PARS = c('L', 'FS', 'phi', 'Mu', 'd0', 'c0', 'Ups')
## MCMC specification ##
nChains = 2
nThin   = 5
nMCMC   = 20000
nCores  = 30
########################
## run the stan model ##
########################
rstan_options(auto_write = TRUE)
Start = Sys.time()
fit_imp_blue <- sampling(object = m_mod,
data = stan_in,
chains = nChains,
iter = nMCMC,
cores=nCores,
seed=42,
thin=nThin,
pars=PARS)
Finish = Sys.time()
Finish-Start
#################
##  Save Model ##
#################
saveRDS(fit_imp_blue, file = "./03_Data/ZZ_Temp/fit_imp.rds")
# Extract model paramters and posterior predictions
##############################################################
fit_imp <- readRDS(file = "./03_Data/ZZ_Temp/fit_imp.rds")
############################
## Extract the parameters ##
############################
phi = rstan::extract(fit_imp, par='phi')[[1]]
mu = rstan::extract(fit_imp, par='Mu')[[1]]
##########################################
## Posterior predictive counterfactuals ##
##########################################
Y0_imp = NA*mu
nIter = dim(mu)[1]
nUnits = dim(mu)[2]
nTimes = dim(mu)[3]
for (b in 1:nIter) {
for (i in 1:nUnits) {
for (t in 1:nTimes) {
Y0_imp[b,i,t] = rnbinom( 1, mu=mu[b,i,t], size=phi[b])
}
}
}
##########
## Save ##
##########
save(Y0_imp, file = "./HepCPeerIntervention/03_Data/ZZ_Temp/posterior_predictions_imp.RData")
save(Y0_imp, file = "./03_Data/ZZ_Temp/posterior_predictions_imp.RData")
# Run the Bayesian Factor Model of
# Nethery, R. C. et al. Integrated causal-predictive machine learning models
# for tropical cyclone epidemiology. Biostatistics 24, 449â€“464 (2023).
# for the number of people starting treatment in the Registry
#######################################
rm(list=ls())
library(rstan)
library(rstanarm)
library(bayesplot)
library(splines)
library(loo)
# maximum number of latent factors ##
k <- 1
## load the stan model ##
m_mod <- stan_model("./04_Code/analysis/only-outcome-models/Functions/MC_neg_binom.stan",
auto_write=T)
## load data ##
load('./03_Data/ZZ_Temp/panel_het_blue.RData')
###########################
## extract and prep data ##
###########################
print(paste("The outcome variable is:", panel_list$Outcome_var))
## set up the list of data for stan call ##
stan_in <- list(k = k, ## k is user-specified number of factors ##
m = ncol(panel_list$D),       # m corresponds to T in our notation (number of time points) ##
n = nrow(panel_list$D),       # n is number of counties ##
p = panel_list$Peers, ## p is the current exposure matrix ##
cp = panel_list$cum_Peers, ## cp is the cumulative peer-month exposure matrix ##
cps = panel_list$spline_base, ## base for spline of cumulative peer month ##
v = dim(panel_list$spline_base)[3], ## number of spline parameters ##
g = as.vector(panel_list$G), ## G is a vector with first time periods units are treated ##
tt = panel_list$TreatTime, ## Time in treatment
d = panel_list$D, ## Treatment indicator matrix
ld = panel_list$LDtreat, ## Treatment/ Lockdown interaction
y = panel_list$Y ##  Outcome ##
)
###########################
##  model specifications ##
###########################
## Decide which parameters to return ##
PARS = c( 'Mu', 'phi_a', 'phi_0', 'FS', 'L', 'Ups',
'theta1', 'theta2',
'd0', 'c0', 'Count')
## MCMC specification ##
nChains = 2
nThin   = 5
nMCMC   = 20000
nCores  = 30
########################
## run the stan model ##
########################
rstan_options(auto_write = TRUE)
Start = Sys.time()
fit_het_blue <- sampling(object = m_mod,
data = stan_in,
chains = nChains,
iter = nMCMC,
cores = nCores,
seed = 42,
thin = nThin,
pars = PARS)
Finish = Sys.time()
Finish-Start
##################################################
##  First glance at treatment effect parameters ##
##################################################
summary_stats <- summary(fit_het_blue)
summary_stats$summary[grep("theta", rownames(summary_stats$summary)), ]
summary_stats$summary[grep("phi",
rownames(summary_stats$summary)), ]
#################
##  Save Model ##
#################
saveRDS(fit_het_blue, file = "./03_Data/ZZ_Temp/fit_het_blue.rds")
##  Posterior predictions of the counterfactuals using a copula
##############################################################################
fit_het_blue <- readRDS(file = "./03_Data/ZZ_Temp/fit_het_blue.rds")
load('./03_Data/ZZ_Temp/panel_het_blue.RData')
############################
## Extract the parameters ##
############################
phi_a <- rstan::extract(fit_het_blue, par='phi_a')[[1]]
phi_0 <- rstan::extract(fit_het_blue, par='phi_0')[[1]]
mu <- rstan::extract(fit_het_blue, par='Mu')[[1]]
count <- rstan::extract(fit_het_blue, par='Count')[[1]]
Y <- panel_list$Y
G <- panel_list$G
nIter <- dim(mu)[1]
nUnits <- dim(mu)[2]
nTimes <- dim(mu)[3]
##############################################
##  Set prior for the correlation parameter ##
##############################################
rho_vals <- c(1, .75, .5, 0, -1)
rho_mins <- c(.75, .5, 0, -1)
rho_maxs <- c(1, 1, 1, 1)
# one correlation value
rho_static <- as.data.frame(matrix(NA, nrow = length(rho_vals), ncol = nIter))
for (val in seq_along(rho_vals)) {
rho_static[val, ] <- rep(rho_vals[val], nIter)
}
# correlation values drawn from prior distribution
rho_prior <- as.data.frame(matrix(NA, nrow = length(rho_maxs), ncol = nIter))
for (val in 1:length(rho_mins)) {
rho_prior[val, ] <- runif(nIter,
min = rho_mins[val],
max = rho_maxs[val])
}
rho_df <- rbind(rho_static, rho_prior)
rho_vector <- c(as.character(rho_vals), paste0("unif[", rho_mins, ",", rho_maxs,"]"))
####################################################
##  Get the percentiles from outcome distribution ##
####################################################
## Get P(x <= X)  ##
percentile_max <- NA*mu
for (b in 1:nIter) {
for (i in 1:nUnits) {
for (t in 1:nTimes) {
if (t < G[i]) {
percentile_max[b,i,t] <- pnbinom(Y[i,t],
mu=mu[b,i,t],
size=phi_0[b])
} else {
percentile_max[b,i,t] <- pnbinom(Y[i,t],
mu=mu[b,i,t],
size=phi_a[b])
}
}
}
}
## Get P(x <= X-1)  ##
percentile_min <- NA*mu
for (b in 1:nIter) {
for (i in 1:nUnits) {
for (t in 1:nTimes) {
if (t < G[i]) {
percentile_min[b,i,t] <- pnbinom(Y[i,t]-1,
mu=mu[b,i,t],
size=phi_0[b])
} else {
percentile_min[b,i,t] <- pnbinom(Y[i,t]-1,
mu=mu[b,i,t],
size=phi_a[b])
}
}
}
}
########################
##  Draw a percentile ##
########################
percentile <- NA*mu
for (b in 1:nIter) {
for (i in 1:nUnits) {
for (t in 1:nTimes) {
percentile[b,i,t] <- runif(1,
min = percentile_min[b,i,t],
max = percentile_max[b,i,t])
}
}
}
##############################################################
##  Introduce the correlation and generate counterfactuals  ##
##############################################################
posterior_predictions_copula_list <- list()
# Loop over each correlation value
for (row_idx in 1:nrow(rho_df)) {
# Get the specific rho value for this iteration
rho <- as.numeric(rho_df[row_idx, ])
################################
##  Introduce the correlation ##
################################
percentile2 <- NA*mu
norm_var1 <- NA*mu
mu2_given_norm_var1 <- NA*mu
sd2_given_norm_var1 <- NA*nIter
norm_var2 <- NA*mu
for (b in 1:nIter) {
for (i in 1:nUnits) {
for (t in 1:nTimes) {
## Get first normally distributed variable
norm_var1[b,i,t] <- qnorm(percentile[b,i,t], mean = 0, sd = 1)
## Compute conditional distribution of norm_var2 | norm_var1
mu2_given_norm_var1[b,i,t] <- rho[b] * norm_var1[b,i,t]
sd2_given_norm_var1[b] <- sqrt(1 - rho[b]^2)
## Sample norm_var2 from conditional distribution
norm_var2[b,i,t] <- rnorm(1,
mean = mu2_given_norm_var1[b,i,t],
sd = sd2_given_norm_var1[b])
## Compute percentile of norm_var2 in the conditional distribution
percentile2[b,i,t] <- pnorm(norm_var2[b,i,t], mean = 0, sd = 1)
}
}
}
##############################
##  Generate counterfactual ##
##############################
Y_0 <- NA*mu
for (b in 1:nIter) {
for (i in 1:nUnits) {
for (t in 1:nTimes) {
Y_0[b,i,t] <- qnbinom(p = percentile2[b,i,t],
mu = count[b,i,t],
size = phi_0[b])
}
}
}
## Save the results for this rho value to the list
posterior_predictions_copula_list[[row_idx]] <- Y_0
names(posterior_predictions_copula_list)[row_idx] <- paste0("rho=",
rho_vector[row_idx])
}
##########
## Save ##
##########
save(posterior_predictions_copula_list,
file = "./03_Data/ZZ_Temp/posterior_predictions_copula_list_outcome.RData")
################################################################################
##  Caterpillar plot for SATE with different values for rho
################################################################################
library(ggplot2)
library(dplyr)
library(tidyverse)
install.packages("tidyverse")
################################################################################
##  Caterpillar plot for SATE with different values for rho
################################################################################
library(ggplot2)
library(dplyr)
library(tidyverse)
install.packages("tidyverse")
# Restart R/RStudio first
options(install.packages.check.source = "no")   # prefer binaries when available
install.packages("tidyverse", dependencies = TRUE,
repos = "https://cloud.r-project.org")
################################################################################
##  Caterpillar plot for SATE with different values for rho
################################################################################
library(ggplot2)
library(dplyr)
library(tidyverse)
